<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>표준 내장 객체 (Standard Built-in Object)</title>
        <style>
            /*reset*/
            *{margin: 0; padding: 0;line-height: 1.8;word-break: keep-all; }
            ol,ul{list-style: none;}
            table{border-collapse: collapse; border-spacing: 0;border:1px solid #ccc;text-align: center;margin: 16px; width: 90%;}
            th{border: 1px solid #ccc;font-weight: normal;background: #bbb;}
            td{border: 1px solid #ccc;}


            /*layout*/
            em{
               text-decoration: underline;
                font-style: normal;
                font-weight: 600;
            }

            img{
                padding: 16px;
            }

            .wrap{
                width: 1000px;
                margin: 0 auto;
            }

            .header{
                text-align: center;
                padding: 10%;
            }

            section{
                padding: 30px;
                margin-bottom: 20px;
                background:#f9ecd566;
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <div class="header">
                <h1>
                    JavaScript -표준 내장 객체 (Standard Built-in Object)
                </h1>
                <p>표준 내장 객체(Standard Built-in Object)는 자바스크립트가 기본적으로 가지고 있는 객체들을 의미합니다.</p>
            </div>

            <section>
                <h3>기본 자료형과 객체 자료형</h3>
                <p>기본 자료형: 숫자, 문자열, 불린 3가지</p>
                <img src="./images/standardObject/img1.PNG" alt="">
                <img src="./images/standardObject/img2.PNG" alt="">
            </section>

            <section>
                <h3>기본 자료형과 객체 자료형 모두 속성과 메소드를 사용할 수있다.</h3>
                <p>
                    객체만 가지는 속성과 메소드를 왜 기본 자료형도 가지고 있을까?<br>
                    이는 기본 자료형의 속성 또는 메소드를 사용할 때 자동으로 객체로 변환되기 때문<br>
                    예를 들어 기본 자료형 숫자의 속성이나 메소드를 사용하면, 자동으로 Number 객체 자료형으로 변환되어 속성이나 메소드를 사용 할 수 있다.<br>
                    그렇지만 객체는 아니기때문에 속성이나 메소드를 추가할 수는 없다.
                </p>
                <br>
                <p>
                    그러면 기본 자료형에 속성 또는 메소드를 추가하려면?<br>
                    생성자 함수의 프로토타입에 메소드를 추가하면 된다<br>
                </p>
                <img src="./images/standardObject/img3.PNG" alt="">
            </section>

            <section>
                <h3>Number 객체</h3>
                <p>Number 객체가 가진 메소드</p>
                <table>
                    <tr>
                        <th width="14%">메소드</th>
                        <th width="45%">설명</th>
                        <th>모두 매개 변수로 하나의 수를 입력받는다.</th>
                    </tr>
                    <tr>
                        <td>toExponential()</td>
                        <td>숫자를 지수 표시로 나타낸 문자열을 리턴</td>
                        <td>매개변수는 소수점 몇 자리까지 나타낼지</td>
                    </tr>
                    <tr>
                        <td>toFixed()</td>
                        <td>숫자를 고정소수점 표시로 나타낸 문자열을 리턴</td>
                        <td>매개변수는 소수점 몇 자리까지 나타낼지</td>
                    </tr>
                    <tr>
                        <td>toPrecision()</td>
                        <td>숫자를 길이에 따라 지수 표시 또는 고정소수점 표시로 나타낸 문자열을 리턴</td>
                        <td>매개변수는 유효자리수를 나타냄</td>
                    </tr>
                </table>
                <img src="./images/standardObject/img4.PNG" alt="">
            </section>

            <section>
                <h3>String 객체</h3>
                <p>자기자신을 변경하는 것이 아니라 리턴 될 값만 변경(비파괴적 메소드)</p>
                <table>
                    <tr>
                        <th>속성</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>length</td>
                        <td>문자열의 길이</td>
                    </tr>
                </table>
                <table>
                    <tr>
                        <th>메소드</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>charAt(position)</td>
                        <td>position에 있는 문자를 리턴</td>
                    </tr>
                    <tr>
                        <td>indexOf(serchString,position)</td>
                        <td>일치하는 문자열의 위치를 앞에서부터 인덱스 값을 리턴</td>
                    </tr>
                    <tr>
                        <td>lastIndexOf(serchString,position)</td>
                        <td>
                            일치하는 문자열의 위치를 뒤에서부터 인덱스 값을 리턴
                        </td>
                    </tr>
                    <tr>
                        <td>
                            match(regExp)<br>
                            *regular expression 정규표현식
                        </td>
                        <td>문자열안에 regExp가 있는지 확인<br>
                            없는경우 null 리턴
                        </td>
                    </tr>
                    <tr>
                        <td>replace(regExp,replacement)</td>
                        <td>문자열안에 regExp를 replacement로 바꾼 후 리턴</td>
                    </tr>
                    <tr>
                        <td>search(regExp)</td>
                        <td>regExp와 일치하는 문자열의 위치를 리턴</td>
                    </tr>
                    <tr>
                        <td>slice(start,end)</td>
                        <td>특정 위치의 문자열 리턴</td>
                    </tr>
                    <tr>
                        <td>substr(start,count)</td>
                        <td>start부터 count만큼 문자열을 잘라서 리턴</td>
                    </tr>
                    <tr>
                        <td>substring(start,end)</td>
                        <td>start부터 end까지 문자열을 잘라서 리턴</td>
                    </tr>
                    <tr>
                        <td>toLowerCase()</td>
                        <td>소문자로 리턴</td>
                    </tr>
                    <tr>
                        <td>toUpperCase()</td>
                        <td>대문자로 리턴</td>
                    </tr>
                </table>
                <p>* 특정 문자열이 있는지 확인할 때 indexof()메소드를 활용</p>
                <img src="./images/standardObject/img5.PNG" alt="">
            </section>

            <section>
                <h3>Date 객체</h3>
                <table>
                    <tr>
                        <th>생성자 함수</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>
                            현재 날짜, 시간(now)
                        </td>
                        <td>
                            new Date()<br>
                            특정 날짜는 new Date("2021-07-12")
                        </td>
                    </tr>
                    <tr>
                        <td>연도</td>
                        <td>getFullYear()</td>
                    </tr>
                    <tr>
                        <td>월</td>
                        <td>
                            getMonth()<br>
                            * 원래 월 -1 의 값으로 나온다.(즉, 1~12월이 0~11의 수로) 그래서 월을 구할때는 getMonth 값에 +1을 주어야함
                        </td>
                    </tr>
                    <tr>
                        <td>요일</td>
                        <td>
                            getDay()<br>
                            * 일요일은 0, 월요일은 1, 화요일은 2, 수요일은 3, 목요일은 4, 금요일은 5, 토요일은 6 을 반환한다.
                        </td>
                    </tr>
                    <tr>
                        <td>분</td>
                        <td>getMinute()</td>
                    </tr>
                    <tr>
                        <td>초</td>
                        <td>getSeconds()</td>
                    </tr>
                </table>
                <img src="./images/standardObject/img6.PNG" alt="">
            </section>

            <section>
                <h3>Array 객체</h3>
                <p>*은 파괴적 메소드로 자기자신을 변화시키는 메소드</p>
                <table>
                   <tr>
                       <th width="30%">메소드</th>
                       <th>설명</th>
                   </tr>
                    <tr>
                        <td>concat()</td>
                        <td>매개 변수로 입력한 배열의 요소를 모두 합쳐 배열을 만들어 리턴</td>
                    </tr>
                    <tr>
                        <td>join()</td>
                        <td>배열 안의 모든 요소를 문자열로 만들어 리턴</td>
                    </tr>
                    <tr>
                        <td>pop()*</td>
                        <td>배열의 마지막 요소를 제거하고 리턴</td>
                    </tr>
                    <tr>
                        <td>push()*</td>
                        <td>배열에 마지막에 새로 추가</td>
                    </tr>
                    <tr>
                        <td>reverse()*</td>
                        <td>배열의 순서를 뒤집는다.</td>
                    </tr>
                    <tr>
                        <td>slice()</td>
                        <td>배열의 지정한 부분을 리턴</td>
                    </tr>
                    <tr>
                        <td>sort()*</td>
                        <td>배열의 요소를 정렬</td>
                    </tr>
                    <tr>
                        <td>splice()*</td>
                        <td>지정한 부분을 삭제하고 삭제한 요소를 리턴</td>
                    </tr>
                </table>
                <img src="./images/standardObject/img7.PNG" alt="">
                <img src="./images/standardObject/img8.PNG" alt="">
                <img src="./images/standardObject/img9.PNG" alt="">
                <img src="./images/standardObject/img10.PNG" alt="">
                <p>ECMAScript5에 추가된 메소드</p>
                <table>
                    <tr>
                        <th>메소드</th>
                        <th>설명</th>
                    </tr>
                    <tr>
                        <td>forEach()</td>
                        <td>배열의 요소를 하나씩 뽑아서 반복한다.</td>
                    </tr>
                    <tr>
                        <td>map()</td>
                        <td>콜백 함수에서 리턴하는 것을 기반으로 새로운 배열을 만듭니다.</td>
                    </tr>
                    <tr>
                        <td>filter()</td>
                        <td>콜백 함수에서 true를 리턴하는 것으로만 새로운 배열을 만들어 리턴한다.</td>
                    </tr>
                </table>
                <img src="./images/standardObject/img11.PNG" alt="">
            </section>
        </div>



        <script>

            // 기본 자료형
            // let number = 273;
            // let string = '안녕하세요';
            // let boolean = true;

            // console.log(typeof number);
            // // number
            // console.log(typeof string);
            // //string
            // console.log(typeof boolean);
            // // boolean

            // 객체 자료형 - 생성자 함수를 이용
            // let number = new Number(273);
            // let string = new String('안녕하세요');
            // let boolean = new Boolean(true);
            //
            // console.log(typeof number);
            // console.log(typeof string);
            // console.log(typeof boolean);
            // object

            // let origin = 270;
            //
            // Number.prototype.method = function(){
            //     return 'Primitive Method';
            // };
            //
            // console.log(origin.method());
            // Primitive Method

            // let number = 273.5102020;
            //
            // console.log(number.toExponential(2));
            // // 2.74e+2
            // console.log(number.toFixed(2));
            // // 273.51
            // console.log(number.toPrecision(2));
            // // 2.7e+2

            // let string = '안녕하세요. 좋은 아침입니다.';
            //  if (string.indexOf('아침') >= 0){
            //      console.log('그러게요 좋은 아침이에요~');
            //  }

            // 일치하는 문자열이 없는 경우 -1을 리턴

            // console.log(new Date());
            // // Mon Jun 07 2021 17:00:39 GMT+0900
            //
            // console.log(new Date().getFullYear());
            // // 2021
            //
            // console.log(new Date().getMonth() + 1);
            // // 6
            //
            // console.log(new Date().getDate());
            // // 7
            //
            // console.log( new Date().getDay());
            // // 1 = 월요일
            //
            // console.log( new Date().getMinutes());
            // // 0
            // console.log( new Date().getSeconds());
            // // 39

            // // 기본 메소드를 활용한 배열 가공
            // let array = [{
            //     name: '고구마',
            //     price: 1000
            // },{
            //     name: '감자',
            //     price: 500
            // },{
            //     name: '바나나',
            //     price: 1500
            // }];
            //
            // let popped =array.pop();
            // console.log(popped);
            // // {name: "바나나", price: 1500}
            // console.log(array);
            // // 0: {name: "고구마", price: 1000}
            // // 1: {name: "감자", price: 500}
            //
            // array.push(popped);
            // console.log(array);
            // // 0: {name: "고구마", price: 1000}
            // // 1: {name: "감자", price: 500}
            // // 2: {name: "바나나", price: 1500}

            // sort 메소드를 활용한 배열 정렬
            // let arrayA = ['고구마', '사과', '바나나'];
            // let arrayB = [{
            //     name: '사과',
            //     price: 800
            // },{
            //     name: '감자',
            //     price: 500
            // },{
            //     name: '바나나',
            //     price: 900
            // }];
            //
            // arrayA.sort();
            // console.log(arrayA);
            // // (3)["감자", "고구마", "바나나"]
            //
            // console.log(arrayA.reverse());
            // // (3)["바나나", "고구마", "감자"]
            //
            // //가격순으로 정리
            // console.log(arrayB);
            // arrayB.sort(function (itemA, itemB) {
            //     return itemA.price - itemB.price;
            // });
            // console.log(arrayB);
            // 0: {name: "감자", price: 500}
            // 1: {name: "사과", price: 800}
            // 2: {name: "바나나", price: 900}

            //오름차순
            // array.sort(function(a, b) {
            //     return a - b;
            // });

            //내림차순
            // array.sort(function(a, b) {
            //     return b - a;
            // });

            //이름순으로 정리 -유니코드 기반
            // arrayB.sort(function (itemA, itemB) {
            //     if (itemA.name < itemB.name) {
            //         return - 1;
            //     } else if (itemA.name > itemB.name) {
            //         return 1;
            //     } else {
            //         return 0;
            //     }
            // });
            // console.log(arrayB);
            // 0: {name: "감자", price: 500}
            // 1: {name: "바나나", price: 900}
            // 2: {name: "사과", price: 800}

            let array = [52, 273, 32];

            // forEach() 메소드
            array.forEach(function (item, index) {
                console.log(index + '번째 요소는 ' + item + '입니다.');
            });
            // 0번째 요소는 52입니다.
            // 1번째 요소는 273입니다.
            // 2번째 요소는 32입니다.

            // map() 메소드
            let outputA = array.map(function (item, index) {
                return item * item;
            });
            console.log(outputA);
            // (3)[2704, 74529, 1024]

            // filter() 메소드
            let outputB = array.filter(function (item, index) {
                //짝수만 출력
                return item % 2 == 0;
            });
            console.log(outputB);
            // (2)[52, 32]





















        </script>
    </body>
</html>